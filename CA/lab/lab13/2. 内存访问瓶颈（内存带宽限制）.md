lab 13

1. chunk会比slice要快（访存更快 spatial locality）

### **2. 内存访问瓶颈（内存带宽限制）**

- 多线程同时访问内存时，**内存带宽可能成为瓶颈**，尤其是密集计算（如矩阵乘法）需要频繁读写数据。
- 如果所有线程同时访问内存，内存控制器可能无法满足高并发需求，导致性能无法线性提升。

### **3. 缓存竞争（Cache Contention）**

- 多核 CPU 的每个核心通常有独立的 L1/L2 缓存，但共享 L3 缓存或内存控制器。
- 如果多个线程频繁访问**同一缓存行（Cache Line）**，会导致 **"False Sharing"（伪共享）**，即不同线程的无关数据位于同一缓存行，引发不必要的缓存同步，降低性能。







ex2

### **（1）线程创建与销毁**

- OpenMP 在运行时需要创建和管理线程（如 `fork-join` 模型），这会引入额外开销。
- 当线程数过多时，**线程调度和上下文切换的开销可能超过并行计算带来的收益**，导致性能下降。

### **（2）任务调度（Scheduling）**

- OpenMP 默认使用静态调度（`schedule(static)`），但如果任务分配不均，部分线程可能提前完成，导致**负载不均衡**。
- 动态调度（`schedule(dynamic)`）可以减少负载不均衡，但会增加调度开销。





ex4

### **(1) 作用**

- **`#pragma omp taskwait`** 确保当前任务的所有子任务（如左右子数组的排序）**完成后再继续执行后续代码**（如 `merge`）。
- 类似于并行编程中的 **"同步点"**，防止数据竞争（Data Race）。

### **(2) 如果省略 `taskwait`**

- **问题**：父任务可能**不等子任务完成**就直接执行 `merge`，导致：

  - **数据错误**：合并时子数组尚未排序。
  - **未定义行为**：访问未初始化的内存。

- **示例**：

  c

  

  复制

  

  下载

  ```
  #pragma omp task  // 排序左半（异步）
  sort_left();
  #pragma omp task  // 排序右半（异步）
  sort_right();
  // 如果没有 taskwait，merge 可能在前两个任务完成前执行！
  merge(); 
  ```

  → 结果错误！

### **(3) 替代方案**

- 可以用 `#pragma omp taskgroup`（OpenMP 4.0+），它能自动等待所有子任务完成。

------

## **2. `CUT_OFF` 的选择与性能权衡**

### **(1) `CUT_OFF` 的作用**

- **控制任务粒度**：当子数组大小 ≤ `CUT_OFF` 时，改用串行排序。
- **避免过多小任务**：减少任务创建/调度的开销。

### **(2) 不同 `CUT_OFF` 的影响**

| **`CUT_OFF` 取值**        | **优点**               | **缺点**                       |
| :------------------------ | :--------------------- | :----------------------------- |
| **太小**（如 10）         | 并行度高，任务多       | 任务调度开销大，可能比串行更慢 |
| **太大**（如 10,000）     | 减少任务数，降低开销   | 并行度不足，无法充分利用多核   |
| **合理值**（如 500~2000） | 平衡任务开销和并行效率 | 需实验确定最优值               |